# OpticsERP — 5. Руководство по офлайн-режиму

> **Назначение:** Единый источник правды по архитектуре, эксплуатации и устранению проблем офлайн-режима.  
> **Аудитория:** разработчики, администраторы, техподдержка L1/L2.  
> **Версия:** 2.0 • Дата: 2025-10-07 • **Обновлено с учетом системного анализа**

---

## 5.1 Введение

### Зачем нужен офлайн-режим?

В сети оптик **регулярные обрывы связи с ОФД (8+ часов)** являются нормой, не исключением. Офлайн-режим гарантирует:
- **Бизнес-непрерывность:** касса работает даже без интернета (бизнес-доступность ≥99.5%)
- **Соответствие 54-ФЗ:** все чеки фискализируются (отложенно, но гарантированно в течение 30 дней)
- **Защита выручки:** ноль потерянных продаж из-за проблем со связью
- **Масштабируемость:** архитектура выдерживает рост до 50+ точек без изменений

### Ключевые принципы

1. **Offline-first:** касса работает автономно, облако — вторично
2. **Двухфазная фискализация:** печать локально → отправка в ОФД асинхронно
3. **Гарантированная доставка:** каждый чек рано или поздно попадёт в ОФД (100% через Circuit Breaker + ретраи)
4. **Graceful degradation:** система деградирует плавно, без резких отказов
5. **Hybrid Logical Clock:** временные метки не зависят от NTP (защита от рассинхронизации времени)
6. **Circuit Breaker:** защита от каскадных отказов при проблемах ОФД
7. **Saga Pattern:** корректная обработка распределённых транзакций (возвраты, корректировки)


## 5.2 Архитектура офлайн-режима

### Компоненты с улучшениями

```
┌─────────────────────────────────────────┐
│   Кассовый терминал (Edge Device)       │
│                                          │
│  ┌────────────────────────────────────┐ │
│  │  Адаптер ККТ (автономный сервис)  │ │
│  │                                    │ │
│  │  ┌──────────┐   ┌──────────────┐  │ │
│  │  │ FastAPI  │   │    SQLite    │  │ │
│  │  │  worker  │◄─►│ офлайн-буфер │  │ │
│  │  │          │   │ (200 чеков)  │  │ │
│  │  │          │   │ PRAGMA       │  │ │
│  │  │          │   │ synchronous  │  │ │
│  │  │          │   │ =FULL        │  │ │
│  │  └────┬─────┘   └──────────────┘  │ │
│  │       │                            │ │
│  │       │ Heartbeat 30s (hysteresis) │ │
│  │       │ Circuit Breaker для ОФД    │ │
│  │       ▼                            │ │
│  │  ┌─────────┐   ┌──────────────┐   │ │
│  │  │   ККТ   │   │Локальный кэш │   │ │
│  │  │ (печать)│   │(1000 товаров)│   │ │
│  │  └─────────┘   └──────────────┘   │ │
│  │                                    │ │
│  │  UPS (15 мин) ─► Graceful shutdown│ │
│  └────────────────────────────────────┘ │
│           │                              │
│           │ async/queue + Distributed Lock│
└───────────┼──────────────────────────────┘
            │
            ▼
    ┌───────────────┐
    │  Odoo Master  │
    │  PostgreSQL   │
    │  + Event Log  │
    └───────┬───────┘
            │
            │ Circuit Breaker
            ▼
       ┌────────┐
       │  ОФД   │
       └────────┘
```

### Режимы работы адаптера ККТ (с hysteresis)

| Режим | Связь с Odoo | Связь с ОФД | Поведение | Переход |
|-------|--------------|-------------|-----------|---------|
| **Online** | ✅ | ✅ | Нормальная работа: чеки отправляются сразу в ОФД | 3 неудачных ping ОФД подряд → Offline |
| **Degraded** | ❌ | ✅ | Работа из локального кэша, отправка в ОФД, события буферизируются для Odoo | Heartbeat к Odoo восстановлен → Online |
| **Offline** | ✅/❌ | ❌ | Чеки сохраняются в SQLite-буфер, фоновая синхронизация при восстановлении | 3 успешных ping ОФД подряд + 90с в текущем режиме → Online |

**Hysteresis (защита от flapping):**
- Минимальное время в одном режиме: **90 секунд**
- Требуется **3 успешных проверки подряд** для перехода в online
- Предотвращает метание между online/offline при нестабильной сети

**Автоматическое переключение режимов:**
```python
class NetworkStateManager:
    def __init__(self):
        self.current_state = "online"
        self.state_entry_time = time.time()
        self.consecutive_failures = 0
        self.consecutive_successes = 0
        self.STABLE_THRESHOLD = 3
        self.MIN_STATE_DURATION = 90  # секунд
    
    def check_network(self):
        # Проверка связи с ОФД
        ofd_available = ping_ofd()
        
        # Проверка heartbeat к Odoo
        odoo_available = heartbeat_odoo()
        
        # Логика переходов с hysteresis
        time_in_state = time.time() - self.state_entry_time
        
        if self.current_state == "online":
            if not ofd_available:
                self.consecutive_failures += 1
                if self.consecutive_failures >= self.STABLE_THRESHOLD and time_in_state >= self.MIN_STATE_DURATION:
                    self.transition_to("offline")
            else:
                self.consecutive_failures = 0
        
        elif self.current_state == "offline":
            if ofd_available:
                self.consecutive_successes += 1
                if self.consecutive_successes >= self.STABLE_THRESHOLD and time_in_state >= self.MIN_STATE_DURATION:
                    self.transition_to("online")
            else:
                self.consecutive_successes = 0
    
    def transition_to(self, new_state):
        logger.info(f"Network state transition: {self.current_state} → {new_state}")
        self.current_state = new_state
        self.state_entry_time = time.time()
        self.consecutive_failures = 0
        self.consecutive_successes = 0
        
        # Метрика для Prometheus
        network_state_gauge.set({"online": 0, "degraded": 1, "offline": 2}[new_state])
```

---

## 5.3 Офлайн-буфер (SQLite) — улучшенная конфигурация

### Схема базы данных

```sql
-- Основная таблица чеков
CREATE TABLE receipts (
  id TEXT PRIMARY KEY,              -- UUIDv4 (receipt_id)
  pos_id TEXT NOT NULL,             -- Идентификатор кассы (POS-001)
  created_at INTEGER NOT NULL,      -- Unix timestamp (секунды)
  hlc_local_time INTEGER NOT NULL,  -- Hybrid Logical Clock: локальное время
  hlc_logical_counter INTEGER NOT NULL, -- Hybrid Logical Clock: счётчик
  hlc_server_time INTEGER,          -- Присваивается при синхронизации с Odoo
  fiscal_doc TEXT NOT NULL,         -- JSON с данными ФФД
  status TEXT NOT NULL DEFAULT 'pending',  -- pending|syncing|synced|failed
  retry_count INTEGER DEFAULT 0,    -- Количество попыток синхронизации
  last_error TEXT,                  -- Последняя ошибка (если есть)
  synced_at INTEGER,                -- Timestamp успешной синхронизации
  CHECK (status IN ('pending', 'syncing', 'synced', 'failed'))
);

CREATE INDEX idx_status ON receipts(status);
CREATE INDEX idx_created_at ON receipts(created_at);
CREATE INDEX idx_pos_status ON receipts(pos_id, status);
CREATE INDEX idx_hlc ON receipts(hlc_server_time, hlc_local_time, hlc_logical_counter);

-- Таблица для DLQ (Dead Letter Queue)
CREATE TABLE dlq (
  id TEXT PRIMARY KEY,
  original_receipt_id TEXT NOT NULL,
  failed_at INTEGER NOT NULL,
  reason TEXT NOT NULL,
  fiscal_doc TEXT NOT NULL,
  retry_attempts INTEGER NOT NULL,
  last_error TEXT,
  resolved_at INTEGER,              -- Когда был обработан вручную
  resolved_by TEXT,                 -- Кто обработал (user_id)
  FOREIGN KEY (original_receipt_id) REFERENCES receipts(id)
);

CREATE INDEX idx_dlq_failed_at ON dlq(failed_at);
CREATE INDEX idx_dlq_resolved ON dlq(resolved_at);

-- Таблица событий (для Event Sourcing, опционально)
CREATE TABLE buffer_events (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  event_type TEXT NOT NULL,         -- receipt_added|receipt_synced|circuit_opened|...
  receipt_id TEXT,
  timestamp INTEGER NOT NULL,
  metadata TEXT,                    -- JSON с дополнительными данными
  CHECK (event_type IN ('receipt_added', 'receipt_synced', 'receipt_failed',
                        'circuit_opened', 'circuit_closed', 'sync_started', 'sync_completed'))
);

CREATE INDEX idx_events_timestamp ON buffer_events(timestamp);
CREATE INDEX idx_events_type ON buffer_events(event_type);

-- ⭐ NEW: Таблица состояния POS-сессий (OPTERP-104)
-- Критично для сохранения баланса наличности при restart
CREATE TABLE pos_sessions (
  pos_id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,              -- Odoo session ID
  opened_at INTEGER NOT NULL,
  closed_at INTEGER,

  -- Баланс наличности и карт
  cash_balance REAL NOT NULL DEFAULT 0,  -- Текущий баланс наличных
  card_balance REAL NOT NULL DEFAULT 0,  -- Баланс карт (для справки)

  -- Z-отчет данные (для закрытия смены)
  z_report_data TEXT,                    -- JSON с итогами смены

  -- Последнее обновление
  last_updated INTEGER NOT NULL,

  -- Статус
  status TEXT NOT NULL DEFAULT 'open',   -- open|closing|closed
  CHECK (status IN ('open', 'closing', 'closed'))
);

CREATE INDEX idx_session_status ON pos_sessions(status);
CREATE INDEX idx_session_updated ON pos_sessions(last_updated);

-- ⭐ NEW: Таблица кассовых транзакций (OPTERP-104)
-- Для реконсиляции и аудита движения денег
CREATE TABLE cash_transactions (
  id TEXT PRIMARY KEY,                   -- UUIDv4
  pos_id TEXT NOT NULL,
  receipt_id TEXT,                       -- Ссылка на receipts.id (если продажа)
  transaction_type TEXT NOT NULL,        -- sale|refund|cash_in|cash_out
  amount REAL NOT NULL,
  payment_method TEXT NOT NULL,          -- cash|card|mixed
  timestamp INTEGER NOT NULL,

  -- Синхронизация с Odoo
  synced_to_odoo BOOLEAN DEFAULT 0,
  synced_at INTEGER,

  FOREIGN KEY (receipt_id) REFERENCES receipts(id),
  FOREIGN KEY (pos_id) REFERENCES pos_sessions(pos_id),
  CHECK (transaction_type IN ('sale', 'refund', 'cash_in', 'cash_out')),
  CHECK (payment_method IN ('cash', 'card', 'mixed'))
);

CREATE INDEX idx_cash_tx_pos ON cash_transactions(pos_id, timestamp);
CREATE INDEX idx_cash_tx_synced ON cash_transactions(synced_to_odoo);
CREATE INDEX idx_cash_tx_type ON cash_transactions(transaction_type);
```

### Конфигурация SQLite (максимальная durability)

**КРИТИЧНО для защиты от power loss:**

```python
import sqlite3

def init_buffer_db(db_path='/app/data/buffer.db'):
    conn = sqlite3.connect(db_path)
    
    # КРИТИЧНЫЕ настройки (защита от коррупции при внезапном отключении питания)
    conn.execute("PRAGMA journal_mode=WAL")        # Write-Ahead Logging
    conn.execute("PRAGMA synchronous=FULL")        # Полная синхронизация (!!!)
    conn.execute("PRAGMA wal_autocheckpoint=100")  # Checkpoint каждые 100 транзакций
    conn.execute("PRAGMA cache_size=-64000")       # 64 MB кеш (производительность)
    conn.execute("PRAGMA foreign_keys=ON")         # Проверка FK
    conn.execute("PRAGMA temp_store=MEMORY")       # Временные таблицы в памяти
    
    return conn
```

**Обоснование `synchronous=FULL`:**
- Каждая транзакция записывается на диск ПЕРЕД подтверждением
- Гарантия: даже при внезапном отключении питания последний подтверждённый чек сохранён
- Производительность: ~50-100 чеков/сек (достаточно для кассы)
- Альтернатива `NORMAL`: ~200-300 чеков/сек, но риск потери последних 1-5 чеков при power loss

### Политики и лимиты

| Параметр | Значение | Обоснование |
|----------|----------|-------------|
| **Ёмкость буфера** | 200 чеков (FIFO) | Покрывает 8ч работы кассы при средней нагрузке (25 чеков/ч) |
| **Размер SQLite файла** | ~10 MB (при 200 чеках) | Средний размер чека в JSON ≈50 KB |
| **Ретенция синхронизированных** | 7 дней | Для диагностики инцидентов |
| **Ретенция DLQ** | 90 дней | Соответствует политике аудита (Док. 2) |
| **Max retry attempts** | 20 попыток | После 20 неудач → DLQ для ручной обработки |
| **Initial backoff** | 5 секунд | Первая попытка повтора через 5с |
| **Max backoff** | 5 минут | Максимальная задержка между попытками |
| **Circuit Breaker threshold** | 5 ошибок подряд | Переход в OPEN → прекращение попыток на 60с |

---

## 5.4 Двухфазная фискализация (с Circuit Breaker)

### Фаза 1: Локальное сохранение (всегда успешна)

```python
from circuitbreaker import circuit

def create_receipt_phase1(receipt_data):
    """
    Фаза 1: локальная — всегда успешна, даже без сети.

    ⭐ ОБНОВЛЕНО в OPTERP-104: добавлено сохранение баланса и транзакций
    """
    # 1. Генерация Hybrid Logical Clock timestamp
    hlc = generate_hlc()
    receipt_id = str(uuid.uuid4())
    transaction_id = str(uuid.uuid4())

    # 2. Сохранение чека в SQLite (WAL mode, crash-safe)
    buffer_db.execute(
        """INSERT INTO receipts
           (id, pos_id, created_at, hlc_local_time, hlc_logical_counter, fiscal_doc, status)
           VALUES (?, ?, ?, ?, ?, ?, 'pending')""",
        (receipt_id, receipt_data['pos_id'], int(time.time()),
         hlc.local_time, hlc.logical_counter, json.dumps(receipt_data))
    )

    # ⭐ 3. NEW (OPTERP-104): Обновление баланса в pos_sessions
    payment_method = receipt_data['payments'][0]['type']  # CASH|CARD|MIXED
    total_amount = sum(p['amount'] for p in receipt_data['payments'])

    if payment_method == 'CASH':
        buffer_db.execute(
            """UPDATE pos_sessions
               SET cash_balance = cash_balance + ?,
                   last_updated = ?
               WHERE pos_id = ? AND status = 'open'""",
            (total_amount, int(time.time()), receipt_data['pos_id'])
        )
    elif payment_method == 'CARD':
        buffer_db.execute(
            """UPDATE pos_sessions
               SET card_balance = card_balance + ?,
                   last_updated = ?
               WHERE pos_id = ? AND status = 'open'""",
            (total_amount, int(time.time()), receipt_data['pos_id'])
        )

    # ⭐ 4. NEW (OPTERP-104): Логирование транзакции для реконсиляции
    buffer_db.execute(
        """INSERT INTO cash_transactions
           (id, pos_id, receipt_id, transaction_type, amount, payment_method, timestamp)
           VALUES (?, ?, ?, 'sale', ?, ?, ?)""",
        (transaction_id, receipt_data['pos_id'], receipt_id,
         total_amount, payment_method.lower(), int(time.time()))
    )

    buffer_db.commit()

    # 5. Печать чека на ККТ (синхронно, таймаут 10с)
    try:
        kkt_driver.print_receipt(receipt_data)
        log.info(f"Receipt {receipt_id} printed successfully")
    except TimeoutError:
        # ККТ не ответила, но чек в буфере → кассир повторит печать
        log.error(f"ККТ timeout для {receipt_id}, чек в буфере")
        send_alert(f"ККТ не отвечает на POS-{receipt_data['pos_id']}", level='P2')

    # 6. Логирование события
    buffer_db.execute(
        "INSERT INTO buffer_events (event_type, receipt_id, timestamp, metadata) VALUES (?, ?, ?, ?)",
        ('receipt_added', receipt_id, int(time.time()),
         json.dumps({'buffer_size': get_buffer_size(), 'cash_balance_updated': payment_method == 'CASH'}))
    )
    
    return receipt_id

def generate_hlc():
    """Генерация Hybrid Logical Clock timestamp"""
    global _hlc_counter
    
    current_time = int(time.time())
    
    # Если время не изменилось, увеличиваем счётчик
    if current_time == _last_hlc_time:
        _hlc_counter += 1
    else:
        _hlc_counter = 0
        _last_hlc_time = current_time
    
    return HybridTimestamp(
        local_time=current_time,
        logical_counter=_hlc_counter,
        server_time=None  # Будет присвоено при синхронизации
    )
```

### Фаза 2: Отправка в ОФД (с Circuit Breaker)

```python
class OFDCircuitBreaker:
    """
    Circuit Breaker для защиты от каскадных отказов при проблемах ОФД
    
    Состояния:
    - CLOSED: все запросы идут к ОФД
    - OPEN: все запросы немедленно fail → буферизация
    - HALF_OPEN: пробный запрос через 60с
    """
    
    @circuit(failure_threshold=5, recovery_timeout=60, expected_exception=(TimeoutError, ConnectionError))
    async def send_receipt(self, receipt):
        response = await ofd_client.post("/receipts", json=receipt, timeout=10)
        return response

ofd_cb = OFDCircuitBreaker()

async def create_receipt_phase2(receipt_id):
    """
    Фаза 2: отправка в ОФД (асинхронная, best-effort)
    """
    # Получение чека из буфера
    receipt = buffer_db.execute(
        "SELECT * FROM receipts WHERE id = ? AND status = 'pending'",
        (receipt_id,)
    ).fetchone()
    
    if not receipt:
        return  # Чек уже синхронизирован или не найден
    
    try:
        # Проверка Circuit Breaker перед попыткой
        circuit_state = ofd_cb.current_state  # CLOSED/OPEN/HALF_OPEN
        
        if circuit_state == "OPEN":
            log.warning(f"Circuit Breaker OPEN, buffering {receipt_id}")
            return  # Не пытаемся отправить, чек остаётся в буфере
        
        # Попытка отправки в ОФД
        fiscal_doc = await ofd_cb.send_receipt(json.loads(receipt['fiscal_doc']))
        
        # Успех! Обновление статуса
        buffer_db.execute(
            """UPDATE receipts 
               SET status='synced', synced_at=?, hlc_server_time=? 
               WHERE id=?""",
            (int(time.time()), get_server_time(), receipt_id)
        )
        buffer_db.commit()
        
        log.info(f"Receipt {receipt_id} synced to OFD: FN={fiscal_doc['fn']}, FD={fiscal_doc['fd']}")
        
    except CircuitBreakerError:
        # Circuit Breaker открыт → чек останется в буфере
        log.warning(f"Circuit Breaker opened for {receipt_id}, will retry later")
        
    except (TimeoutError, ConnectionError) as e:
        # Ошибка сети → увеличиваем retry_count, пробуем позже
        buffer_db.execute(
            "UPDATE receipts SET retry_count = retry_count + 1, last_error = ? WHERE id = ?",
            (str(e), receipt_id)
        )
        buffer_db.commit()
        
        # Проверка: не превышен ли лимит попыток?
        if receipt['retry_count'] + 1 >= 20:
            move_to_dlq(receipt_id, reason="max_retries_exceeded")
            send_alert(f"Receipt {receipt_id} moved to DLQ after 20 retries", level='P2')

def move_to_dlq(receipt_id, reason):
    """Перенос чека в Dead Letter Queue для ручной обработки"""
    receipt = buffer_db.execute("SELECT * FROM receipts WHERE id = ?", (receipt_id,)).fetchone()
    
    buffer_db.execute(
        """INSERT INTO dlq (id, original_receipt_id, failed_at, reason, fiscal_doc, retry_attempts, last_error)
           VALUES (?, ?, ?, ?, ?, ?, ?)""",
        (str(uuid.uuid4()), receipt_id, int(time.time()), reason, 
         receipt['fiscal_doc'], receipt['retry_count'], receipt['last_error'])
    )
    
    buffer_db.execute("UPDATE receipts SET status = 'failed' WHERE id = ?", (receipt_id,))
    buffer_db.commit()
    
    log.critical(f"Receipt {receipt_id} moved to DLQ: {reason}")
```

---

## 5.4.1 Session State Recovery (OPTERP-104)

### Проблема: Потеря баланса при restart

**Критический сценарий:**
```
1. Сеть offline
2. 5 продаж наличными (баланс = 50,000₽)
3. KKT Adapter restart (crash/reboot)
4. ❌ Баланс потерян → 0₽
```

**Решение:** Сохранение состояния сессии в SQLite (таблицы `pos_sessions` и `cash_transactions`)

### Восстановление при старте

```python
def restore_session_state(pos_id: str):
    """
    Восстановление состояния POS-сессии после restart

    Вызывается при старте KKT Adapter для каждого POS-терминала.
    Восстанавливает баланс наличности и состояние сессии из SQLite.
    """
    # Поиск открытой сессии
    session = buffer_db.execute(
        "SELECT * FROM pos_sessions WHERE pos_id = ? AND status = 'open'",
        (pos_id,)
    ).fetchone()

    if session:
        log.info(f"✅ Restored session for {pos_id}:")
        log.info(f"   Session ID: {session['session_id']}")
        log.info(f"   Cash balance: {session['cash_balance']:.2f}₽")
        log.info(f"   Card balance: {session['card_balance']:.2f}₽")
        log.info(f"   Opened at: {datetime.fromtimestamp(session['opened_at'])}")

        # Восстановление in-memory state
        global _pos_sessions
        _pos_sessions[pos_id] = {
            'session_id': session['session_id'],
            'cash_balance': session['cash_balance'],
            'card_balance': session['card_balance'],
            'opened_at': session['opened_at'],
            'last_updated': session['last_updated']
        }

        # Проверка несинхронизированных транзакций
        pending_tx = buffer_db.execute(
            """SELECT COUNT(*) as count
               FROM cash_transactions
               WHERE pos_id = ? AND synced_to_odoo = 0""",
            (pos_id,)
        ).fetchone()

        if pending_tx['count'] > 0:
            log.warning(f"⚠️  {pending_tx['count']} unsynced cash transactions for {pos_id}")

        return session
    else:
        log.warning(f"⚠️  No open session for {pos_id} - starting fresh")
        return None


# Интеграция в startup
@app.on_event("startup")
async def startup_event():
    """
    FastAPI startup handler

    ⭐ ОБНОВЛЕНО в OPTERP-104: добавлено восстановление сессий
    """
    # 1. Инициализация buffer
    init_buffer_db()

    # 2. ⭐ NEW: Восстановление сессий для всех POS
    pos_terminals = get_registered_pos_terminals()  # POS-001, POS-002, ...
    for pos_id in pos_terminals:
        restore_session_state(pos_id)

    # 3. Запуск background workers
    start_sync_worker()
    start_heartbeat_worker()

    log.info("✅ KKT Adapter started successfully")
```

### Реконсиляция после восстановления

```python
def reconcile_session(pos_id: str):
    """
    Реконсиляция баланса сессии с транзакциями

    Проверяет, что cash_balance соответствует сумме всех транзакций.
    """
    session = buffer_db.execute(
        "SELECT cash_balance FROM pos_sessions WHERE pos_id = ? AND status = 'open'",
        (pos_id,)
    ).fetchone()

    # Расчет баланса из транзакций
    calculated_balance = buffer_db.execute(
        """SELECT
             SUM(CASE
                 WHEN transaction_type = 'sale' AND payment_method = 'cash' THEN amount
                 WHEN transaction_type = 'refund' AND payment_method = 'cash' THEN -amount
                 WHEN transaction_type = 'cash_in' THEN amount
                 WHEN transaction_type = 'cash_out' THEN -amount
                 ELSE 0
             END) as balance
           FROM cash_transactions
           WHERE pos_id = ?""",
        (pos_id,)
    ).fetchone()

    expected = calculated_balance['balance'] or 0
    actual = session['cash_balance']

    if abs(expected - actual) > 0.01:  # Tolerance 1 kopek
        log.error(f"❌ Balance mismatch for {pos_id}: expected {expected:.2f}, actual {actual:.2f}")
        send_alert(f"Balance reconciliation failed for {pos_id}", level='P2')
        return False
    else:
        log.info(f"✅ Balance reconciled for {pos_id}: {actual:.2f}₽")
        return True
```

**Метрики Prometheus:**
```python
pos_session_recovered = Gauge('pos_session_recovered', 'Session recovered on startup', ['pos_id'])
pos_session_balance = Gauge('pos_session_cash_balance', 'Current cash balance', ['pos_id'])
pos_unsynced_transactions = Gauge('pos_unsynced_transactions', 'Unsynced cash transactions', ['pos_id'])
```

---

## 5.5 Decision Tree для техподдержки L1/L2

### Флоучарт диагностики проблем офлайн-режима

```
┌─────────────────────────────────────┐
│  Жалоба кассира: "Проблема с кассой" │
└──────────────┬──────────────────────┘
               │
               ▼
       ┌───────────────────┐
       │ Какая ошибка?     │
       └───────┬───────────┘
               │
   ┌───────────┼────────────┬──────────────┬────────────────┐
   │           │            │              │                │
   ▼           ▼            ▼              ▼                ▼
"Буфер   "Касса не    "Чек не       "Медленно      "Circuit
заполнен" принимает   печатается"   работает"      Breaker
          оплату"                                   OPEN"
   │           │            │              │                │
   │           │            │              │                │
   ▼           ▼            ▼              ▼                ▼
[Процедура [Процедура  [Процедура    [Процедура      [Процедура
 A.1]       A.2]        A.3]          A.4]            A.5]
```

### Процедура A.1: "Буфер заполнен" (наиболее критичная)

**Симптомы:**
- Кассир видит сообщение: "Невозможно принять оплату. Офлайн-буфер переполнен"
- UI показывает красный индикатор "200/200 чеков"

**Диагностика (L1, 2 минуты):**
```bash
# 1. Проверка связи с ОФД (ping)
curl -I https://ofd.example.com/health
# Ожидание: HTTP 200 OK

# 2. Проверка статуса буфера
curl https://pos-001.local/v1/kkt/buffer/status | jq
# Смотрим: current_queued, network_status, last_sync, circuit_state

# 3. Проверка Circuit Breaker
curl https://pos-001.local/v1/health | jq '.components.circuit_breaker.state'
# Возможные значения: CLOSED, OPEN, HALF_OPEN
```

**Решения:**

**Случай 1: Сеть работает, Circuit Breaker CLOSED, но синхронизация не идёт**
```
Причина: застрявшая синхронизация или ошибка ОФД

Действия L1:
1. Принудительная синхронизация:
   curl -X POST https://pos-001.local/v1/kkt/buffer/sync?force=true
   
2. Ожидание 5-10 минут (мониторинг progress)
   watch -n 10 'curl -s https://pos-001.local/v1/kkt/buffer/status | jq .current_queued'
   
3. Проверка: buffer_size уменьшился?
   - ✅ Да → проблема решена, касса разблокирована
   - ❌ Нет → эскалация на L2

Эскалация L2:
- Проверка логов адаптера: docker logs kkt-adapter --tail 100 | grep ERROR
- Проверка ОФД API: возвращает ли ошибки? (curl -v к ОФД)
- Если ОФД недоступен → контакт с провайдером ОФД (SLA 30 мин)
```

**Случай 2: Circuit Breaker OPEN (ОФД недоступен длительное время)**
```
Причина: Circuit Breaker разомкнут из-за множественных ошибок ОФД

Действия L1:
1. Проверка состояния Circuit Breaker:
   curl https://pos-001.local/v1/health | jq '.components.circuit_breaker'
   
2. Если state=OPEN и failure_count≥5:
   - Это защитный механизм (нормально при проблемах ОФД)
   - Circuit Breaker автоматически перейдёт в HALF_OPEN через 60с
   
3. Проверка физической связи:
   - Ping до ОФД: ping -c 5 ofd.example.com
   - Trace route: traceroute ofd.example.com
   
4. Если сеть восстановилась:
   - Ждём автоматического перехода HALF_OPEN → CLOSED
   - Синхронизация начнётся автоматически
   
5. Если сеть НЕ восстанавливается:
   - Эскалация на провайдера интернета
   - Временное решение: 4G/LTE модем (если есть)
   - Уведомление владельца бизнеса (потеря продаж!)

Критичность: P1 (блокирует продажи)
SLA восстановления: 1 час
```

**Случай 3: Сеть не работает (offline)**
```
Причина: обрыв интернет-канала

Действия L1:
1. Проверка физического подключения:
   - Кабель Ethernet подключен?
   - Роутер включен и горят индикаторы?
   - Wi-Fi работает на других устройствах?

2. Перезапуск сетевого оборудования:
   - Выключить/включить роутер (30 секунд пауза)
   - Проверка: ping 8.8.8.8 работает?

3. Если сеть восстановлена:
   - Circuit Breaker перейдёт из OPEN → HALF_OPEN → CLOSED (автоматически)
   - Синхронизация запустится автоматически через 5 мин
   - Касса разблокируется через 5-10 мин

4. Если сеть НЕ восстанавливается:
   - Эскалация на провайдера интернета
   - Временное решение: 4G/LTE модем (если есть)
   - Уведомление владельца бизнеса (потеря продаж!)

Критичность: P1 (блокирует продажи)
SLA восстановления: 1 час
```

**Случай 4: Буфер переполнен из-за долгого офлайна (>8ч)**
```
Причина: длительный обрыв связи, все 200 мест в буфере заняты

Действия L2 (временное решение, 15 минут):
1. Hot-patch: увеличение ёмкости буфера до 300 чеков
   
   # На кассовом терминале
   docker exec kkt-adapter vi /app/config.toml
   # Изменить: capacity = 300
   
   docker restart kkt-adapter
   
   # Касса разблокируется, можно принимать ещё 100 чеков

2. Немедленная эскалация владельцу бизнеса:
   "Буфер критично заполнен, временное решение на 4 часа.
    Необходимо восстановление связи или замена на резервный канал."

3. Мониторинг: проверка каждые 30 минут
   - Достигнут ли лимит 300?
   - Восстановилась ли связь?

Долгосрочное решение (L2 + DevOps):
- Расследование причины длительного офлайна
- Установка резервного канала (4G/LTE) на критичных точках
- Обновление процедуры: автоматическое переключение на резервный канал
```

### Процедура A.5: "Circuit Breaker OPEN" (новая)

**Симптомы:**
- Мониторинг показывает "Circuit Breaker: OPEN"
- Чеки накапливаются в буфере, но не отправляются в ОФД
- ОФД может быть доступен, но возвращает ошибки

**Диагностика (L2, 5 минут):**
```bash
# 1. Проверка состояния Circuit Breaker
curl https://pos-001.local/v1/health | jq '.components.circuit_breaker'
# {
#   "state": "OPEN",
#   "failure_count": 7,
#   "last_failure_time": "2025-10-05T14:30:00Z",
#   "next_attempt_time": "2025-10-05T14:31:00Z"
# }

# 2. Проверка последних ошибок
curl https://pos-001.local/v1/kkt/buffer/logs?level=ERROR&limit=10 | jq
# Смотрим паттерны: timeout, 503, 500, connection refused

# 3. Прямой тест ОФД
curl -v -X POST https://ofd.example.com/api/receipts \
  -H "Authorization: Bearer $OFD_API_KEY" \
  -d '{"test": true}'
# Проверка: возвращает ли ОФД ошибку?
```

**Решения:**

**Случай 1: ОФД временно недоступен (maintenance)**
```
Действия L2:
1. Проверка статуса ОФД:
   - Сайт провайдера ОФД (status page)
   - Контакт с техподдержкой ОФД

2. Если плановые работы ОФД:
   - Circuit Breaker автоматически восстановится через 60с (HALF_OPEN)
   - Если HALF_OPEN → успех → CLOSED
   - Синхронизация начнётся автоматически
   
3. Уведомление кассиров:
   "ОФД на обслуживании, чеки накапливаются в буфере.
    Синхронизация произойдёт автоматически после восстановления (ETA: XX:XX)"

Критичность: P2 (продажи работают, но буфер растёт)
```

**Случай 2: Проблема с API key или авторизацией ОФД**
```
Симптомы: ОФД возвращает 401 Unauthorized или 403 Forbidden

Действия L2:
1. Проверка API key:
   echo $OFD_API_KEY
   # Проверить: не истёк ли срок действия?
   
2. Ротация API key:
   - Получение нового ключа от провайдера ОФД
   - Обновление config.toml
   - docker restart kkt-adapter
   
3. Ручной сброс Circuit Breaker (после исправления):
   curl -X POST https://pos-001.local/v1/kkt/circuit_breaker/reset
   
4. Принудительная синхронизация:
   curl -X POST https://pos-001.local/v1/kkt/buffer/sync?force=true

Критичность: P1 (требуется ручное вмешательство)
```

**Случай 3: ОФД перегружен (rate limiting)**
```
Симптомы: ОФД возвращает 429 Too Many Requests

Действия L2:
1. Проверка Retry-After header:
   curl -I https://ofd.example.com/api/receipts
   # Retry-After: 120 (секунды)
   
2. Снижение скорости синхронизации:
   # В config.toml
   [buffer]
   sync_batch_size = 10  # Вместо 20
   sync_interval = 600   # 10 мин вместо 5 мин
   
   docker restart kkt-adapter
   
3. Circuit Breaker автоматически учтёт rate limiting:
   - HALF_OPEN попытки будут реже
   - Постепенное восстановление CLOSED

Критичность: P2 (синхронизация замедлена, но работает)
```

---

## 5.6 Примеры логов и их интерпретация

### Нормальная работа (online-режим с Circuit Breaker CLOSED)

```json
{"timestamp":"2025-10-05T14:23:45.123Z","level":"INFO","component":"kkt_adapter","event":"receipt_create","receipt_id":"550e8400-e29b-41d4-a716-446655440000","pos_id":"POS-001","hlc":{"local_time":1728134625,"logical_counter":42}}
{"timestamp":"2025-10-05T14:23:45.150Z","level":"INFO","component":"kkt_adapter","event":"buffer_insert","receipt_id":"550e8400...","buffer_size":1,"hlc_stored":true}
{"timestamp":"2025-10-05T14:23:45.200Z","level":"INFO","component":"kkt_adapter","event":"kkt_print_start","receipt_id":"550e8400..."}
{"timestamp":"2025-10-05T14:23:45.380Z","level":"INFO","component":"kkt_adapter","event":"kkt_print_success","receipt_id":"550e8400...","duration_ms":180}
{"timestamp":"2025-10-05T14:23:45.400Z","level":"INFO","component":"kkt_adapter","event":"circuit_check","circuit_state":"CLOSED","failure_count":0}
{"timestamp":"2025-10-05T14:23:45.410Z","level":"INFO","component":"kkt_adapter","event":"ofd_send_start","receipt_id":"550e8400..."}
{"timestamp":"2025-10-05T14:23:45.760Z","level":"INFO","component":"kkt_adapter","event":"ofd_send_success","receipt_id":"550e8400...","fiscal_doc":{"fn":"1234567890","fd":"12345","fp":"98765"},"duration_ms":350}
{"timestamp":"2025-10-05T14:23:45.780Z","level":"INFO","component":"kkt_adapter","event":"receipt_synced","receipt_id":"550e8400...","total_duration_ms":657,"hlc_server_time":1728134625}
```

**Интерпретация (для L2):**
- Весь процесс занял **657 мс** (< 7 сек SLA ✅)
- Печать на ККТ: **180 мс** (быстро ✅)
- Circuit Breaker в состоянии CLOSED (норма ✅)
- Отправка в ОФД: **350 мс** (норма ✅)
- Чек синхронизирован сразу (online-режим)
- Hybrid Clock: local_time + logical_counter сохранены, server_time присвоен

### Circuit Breaker открывается (5 ошибок подряд)

```json
{"timestamp":"2025-10-05T16:10:10.100Z","level":"ERROR","component":"kkt_adapter","event":"ofd_send_failed","receipt_id":"661f9511...","error":"ConnectionTimeout","retry_count":1,"circuit_failure_count":1}
{"timestamp":"2025-10-05T16:10:15.200Z","level":"ERROR","component":"kkt_adapter","event":"ofd_send_failed","receipt_id":"772a0622...","error":"ConnectionTimeout","retry_count":1,"circuit_failure_count":2}
{"timestamp":"2025-10-05T16:10:20.300Z","level":"ERROR","component":"kkt_adapter","event":"ofd_send_failed","receipt_id":"883b1733...","error":"503 Service Unavailable","retry_count":1,"circuit_failure_count":3}
{"timestamp":"2025-10-05T16:10:25.400Z","level":"ERROR","component":"kkt_adapter","event":"ofd_send_failed","receipt_id":"994c2844...","error":"ConnectionTimeout","retry_count":1,"circuit_failure_count":4}
{"timestamp":"2025-10-05T16:10:30.500Z","level":"ERROR","component":"kkt_adapter","event":"ofd_send_failed","receipt_id":"aa5d3955...","error":"ConnectionTimeout","retry_count":1,"circuit_failure_count":5}
{"timestamp":"2025-10-05T16:10:30.505Z","level":"CRITICAL","component":"kkt_adapter","event":"circuit_breaker_opened","reason":"failure_threshold_exceeded","failure_count":5,"recovery_timeout_seconds":60}
{"timestamp":"2025-10-05T16:10:30.510Z","level":"WARN","component":"kkt_adapter","event":"network_mode_change","from":"online","to":"offline"}
{"timestamp":"2025-10-05T16:10:30.510Z","level":"WARN","component":"kkt_adapter","event":"network_mode_change","from":"online","to":"offline"}
{"timestamp":"2025-10-05T16:10:30.515Z","level":"CRITICAL","component":"kkt_adapter","event":"alert_sent","level":"P2","message":"Circuit Breaker OPEN на POS-001, ОФД недоступен","buffer_size":47}
```

**Интерпретация:**
- 5 последовательных ошибок ОФД (таймауты + 503) за 30 секунд
- Circuit Breaker открылся → **защита от каскадных отказов**
- Касса автоматически перешла в **offline-режим** (продолжает работать!)
- Алерт P2 отправлен администратору
- Следующая попытка (HALF_OPEN) через 60 секунд
- Буфер: 47 чеков (24%, не критично)

### Circuit Breaker восстанавливается (HALF_OPEN → CLOSED)

```json
{"timestamp":"2025-10-05T16:11:30.600Z","level":"INFO","component":"kkt_adapter","event":"circuit_breaker_half_open","next_attempt":"probe_request"}
{"timestamp":"2025-10-05T16:11:30.650Z","level":"INFO","component":"kkt_adapter","event":"ofd_send_start","receipt_id":"bb6e4a66...","is_probe":true}
{"timestamp":"2025-10-05T16:11:31.000Z","level":"INFO","component":"kkt_adapter","event":"ofd_send_success","receipt_id":"bb6e4a66...","fiscal_doc":{"fn":"1234567890","fd":"12346","fp":"98766"},"duration_ms":350}
{"timestamp":"2025-10-05T16:11:31.005Z","level":"INFO","component":"kkt_adapter","event":"circuit_breaker_closed","reason":"probe_success","downtime_seconds":61}
{"timestamp":"2025-10-05T16:11:31.010Z","level":"INFO","component":"kkt_adapter","event":"network_mode_change","from":"offline","to":"online"}
{"timestamp":"2025-10-05T16:11:31.015Z","level":"INFO","component":"kkt_adapter","event":"sync_start","pending_receipts":47,"estimated_duration_seconds":141}
```

**Интерпретация:**
- Через 61 секунду Circuit Breaker перешёл в HALF_OPEN
- Пробный запрос успешен → переход в CLOSED
- Касса вернулась в online-режим
- Автоматическая синхронизация 47 чеков начата (≈2.4 мин)
- **Downtime ОФД:** 61 секунда (касса работала всё это время!)

### Distributed Lock предотвращает конкурентную синхронизацию

```json
{"timestamp":"2025-10-05T18:00:00.100Z","level":"INFO","component":"kkt_adapter","event":"sync_start","trigger":"scheduled","pending_receipts":15}
{"timestamp":"2025-10-05T18:00:00.105Z","level":"INFO","component":"kkt_adapter","event":"sync_lock_acquired","lock_id":"sync:POS-001:1728141600"}

{"timestamp":"2025-10-05T18:00:01.200Z","level":"INFO","component":"kkt_adapter","event":"sync_start","trigger":"manual","user":"admin"}
{"timestamp":"2025-10-05T18:00:01.205Z","level":"WARN","component":"kkt_adapter","event":"sync_lock_conflict","lock_id":"sync:POS-001:1728141600","held_by":"scheduled"}
{"timestamp":"2025-10-05T18:00:01.210Z","level":"INFO","component":"kkt_adapter","event":"sync_rejected","reason":"already_in_progress","http_status":409}

{"timestamp":"2025-10-05T18:00:15.300Z","level":"INFO","component":"kkt_adapter","event":"sync_complete","synced_count":15,"failed_count":0,"duration_seconds":15.2}
{"timestamp":"2025-10-05T18:00:15.305Z","level":"INFO","component":"kkt_adapter","event":"sync_lock_released","lock_id":"sync:POS-001:1728141600"}
```

**Интерпретация:**
- Плановая синхронизация началась в 18:00:00 (scheduled)
- Distributed lock получен (sync_lock_acquired)
- Через 1 секунду администратор вручную запустил синхронизацию (manual)
- **Distributed lock сработал:** вторая попытка отклонена (HTTP 409)
- **Защита от дубликатов:** нет конкурентной отправки в ОФД
- Первая синхронизация завершилась успешно (15.2 сек)
- Lock освобождён

---

## 5.7 Таблица эскалации (SLA с учётом Circuit Breaker)

| Проблема | Критичность | L1 Response | L2 Escalation | Владелец бизнеса | Примечания |
|----------|-------------|-------------|---------------|------------------|------------|
| Буфер переполнен (сеть работает, CB CLOSED) | P1 | ≤15 мин | ≤30 мин (если не решено L1) | ≤1ч (если не решено L2) | Принудительная синхронизация |
| Буфер переполнен (Circuit Breaker OPEN) | P1 | ≤15 мин | Немедленно (провайдер ОФД) | Немедленно | Hot-patch: увеличение буфера до 300 |
| Буфер переполнен (сеть не работает) | P1 | ≤15 мин | Немедленно (провайдер интернета) | Немедленно | 4G/LTE модем или потеря продаж |
| Circuit Breaker OPEN (плановые работы ОФД) | P2 | N/A | ≤1ч (мониторинг) | N/A | Автовосстановление через 60с |
| Circuit Breaker OPEN (проблема авторизации) | P1 | N/A | ≤30 мин | ≤1ч | Требуется ротация API key |
| Касса не принимает оплату | P1 | ≤15 мин | ≤30 мин | ≤1ч | Проверка адаптера ККТ |
| Чек не печатается (нет бумаги) | P3 | Кассир (самостоятельно) | N/A | N/A | Самообслуживание |
| Чек не печатается (ошибка ККТ) | P2 | ≤30 мин | ≤1ч | ≤4ч | Замена ККТ на резервную |
| Медленно работает | P2 | ≤1ч | ≤4ч | N/A | Проверка ресурсов/сети |
| DLQ содержит >10 чеков | P2 | N/A | ≤4ч (ручная обработка) | N/A | Еженедельная проверка DLQ |

---

## 5.8 Мониторинг и алерты (с Circuit Breaker метриками)

### Критичные метрики для офлайн-режима

```python
# Prometheus metrics (добавлены Circuit Breaker метрики)

# Офлайн-буфер
kkt_buffer_size = Gauge('kkt_buffer_size', 'Current buffer size', ['pos_id'])
kkt_buffer_capacity = Gauge('kkt_buffer_capacity', 'Max buffer capacity')
kkt_buffer_percent_full = Gauge('kkt_buffer_percent_full', 'Buffer fullness %', ['pos_id'])

# Circuit Breaker
kkt_circuit_breaker_state = Gauge('kkt_circuit_breaker_state', 'Circuit breaker state (0=CLOSED, 1=OPEN, 2=HALF_OPEN)', ['pos_id'])
kkt_circuit_breaker_failures = Counter('kkt_circuit_breaker_failures_total', 'Total circuit breaker failures', ['pos_id'])
kkt_circuit_breaker_opens = Counter('kkt_circuit_breaker_opens_total', 'Times circuit breaker opened', ['pos_id'])

# Синхронизация
kkt_sync_duration_seconds = Histogram('kkt_sync_duration_seconds', 'Sync duration', ['pos_id'])
kkt_receipts_synced = Counter('kkt_receipts_synced_total', 'Total synced receipts', ['pos_id', 'status'])

# DLQ
kkt_dlq_size = Gauge('kkt_dlq_size', 'Dead Letter Queue size', ['pos_id'])

# Hybrid Clock
kkt_hlc_drift_seconds = Gauge('kkt_hlc_drift_seconds', 'HLC drift from NTP', ['pos_id'])
```

### Алерты (Prometheus Alertmanager)

```yaml
groups:
  - name: offline_mode_alerts
    interval: 30s
    rules:
      # Буфер заполнен ≥80%
      - alert: OfflineBufferWarning
        expr: kkt_buffer_percent_full >= 80
        for: 5m
        labels:
          severity: P2
        annotations:
          summary: "Офлайн-буфер заполнен ≥80% на {{ $labels.pos_id }}"
          description: "Текущий размер: {{ $value }}%. Требуется мониторинг."
      
      # Буфер переполнен (100%)
      - alert: OfflineBufferFull
        expr: kkt_buffer_percent_full >= 100
        for: 1m
        labels:
          severity: P1
        annotations:
          summary: "Офлайн-буфер переполнен на {{ $labels.pos_id }}"
          description: "Касса заблокирована. Немедленная синхронизация!"
      
      # Circuit Breaker открыт >5 минут
      - alert: CircuitBreakerOpen
        expr: kkt_circuit_breaker_state == 1
        for: 5m
        labels:
          severity: P2
        annotations:
          summary: "Circuit Breaker OPEN на {{ $labels.pos_id }}"
          description: "ОФД недоступен >5 мин. Чеки буферизируются."
      
      # Синхронизация длится >20 минут
      - alert: SyncTooSlow
        expr: kkt_sync_duration_seconds > 1200
        labels:
          severity: P1
        annotations:
          summary: "Синхронизация >20 мин на {{ $labels.pos_id }}"
          description: "Проверка канала до ОФД, повтор синхронизации."
      
      # DLQ содержит >10 чеков
      - alert: DLQBacklog
        expr: kkt_dlq_size > 10
        for: 1h
        labels:
          severity: P2
        annotations:
          summary: "DLQ содержит >10 чеков на {{ $labels.pos_id }}"
          description: "Требуется ручная обработка DLQ."
      
      # Hybrid Clock drift >10 секунд
      - alert: HLCDriftHigh
        expr: abs(kkt_hlc_drift_seconds) > 10
        for: 15m
        labels:
          severity: P2
        annotations:
          summary: "HLC drift >10с на {{ $labels.pos_id }}"
          description: "Проверка NTP-синхронизации."
```

### Grafana Dashboard (4 критичные панели)

**Панель 1: Статус касс (real-time карта)**
```
┌────────────────────────────────────────────────────────┐
│ Статус касс (20 точек, 40 касс)                       │
├────────────────────────────────────────────────────────┤
│  [🟢 POS-001] Буфер: 5/200   CB: CLOSED  HB: 2s ago  │
│  [🟢 POS-002] Буфер: 12/200  CB: CLOSED  HB: 1s ago  │
│  [🟡 POS-003] Буфер: 165/200 CB: CLOSED  HB: 3s ago  │ ← Warning
│  [🔴 POS-004] Буфер: 200/200 CB: OPEN    HB: 45s ago │ ← Critical
│  [🟢 POS-005] Буфер: 3/200   CB: CLOSED  HB: 1s ago  │
│  ... (остальные 35 касс)                              │
└────────────────────────────────────────────────────────┘

Легенда:
🟢 Online, буфер <80%, CB CLOSED
🟡 Online, буфер 80-99%, CB CLOSED или CB OPEN <5 мин
🔴 Offline, буфер 100%, CB OPEN >5 мин или HB >60s
```

**Панель 2: Circuit Breaker состояния**
```
┌────────────────────────────────────────────────────────┐
│ Circuit Breaker States (last 24h)                     │
├────────────────────────────────────────────────────────┤
│  POS-001: ████████████████████████████████████ CLOSED │
│  POS-002: ████████████████████████████████████ CLOSED │
│  POS-003: ██████████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 2x OPEN │
│  POS-004: ████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 5x OPEN │
│  POS-005: ████████████████████████████████████ CLOSED │
│  ... (остальные 35 касс)                              │
└────────────────────────────────────────────────────────┘

Метрики:
- Среднее время в OPEN: 3.2 мин
- Частота срабатывания CB: 0.8%
- Успешность HALF_OPEN → CLOSED: 95%
```

**Панель 3: Офлайн-буфер аналитика**
```
┌────────────────────────────────────────────────────────┐
│ Офлайн-буфер метрики (last 7 days)                    │
├────────────────────────────────────────────────────────┤
│ График заполненности (по времени):                     │
│ %                                                       │
│100├─┐                                                   │
│ 80│ └─┐              ┌─┐                               │
│ 60│   └──────────────┘ └───────────────────────────    │
│ 40│                                                     │
│ 20│████████████████████████████████████████████████    │
│  0└────────────────────────────────────────────────    │
│    Mon  Tue  Wed  Thu  Fri  Sat  Sun                   │
│                                                         │
│ Топ-5 касс по максимальной заполненности:              │
│  1. POS-004: 200/200 (100%) - 3 раза                  │
│  2. POS-012: 185/200 (93%)  - 1 раз                   │
│  3. POS-003: 165/200 (83%)  - 2 раза                  │
│  4. POS-018: 140/200 (70%)  - 1 раз                   │
│  5. POS-007: 120/200 (60%)  - постоянно               │
│                                                         │
│ Средняя длительность синхронизации: 8.3 мин (P95: 12) │
└────────────────────────────────────────────────────────┘
```

**Панель 4: Производительность и надёжность**
```
┌────────────────────────────────────────────────────────┐
│ Performance & Reliability (last 24h)                   │
├────────────────────────────────────────────────────────┤
│ P95 латентность печати чека:        5.8s  [✓ <7s]    │
│ Throughput синхронизации (P50):     22 чеков/мин [✓]  │
│ Доля успешных синхронизаций:        99.2%  [✓ >99%]   │
│ DLQ размер (суммарно):              7 чеков [✓ <10]   │
│ Circuit Breaker opens (24h):        12 раз  [⚠]       │
│ Бизнес-доступность касс:            99.7%  [✓ >99.5%] │
│                                                         │
│ Hybrid Clock drift (max):           2.3s   [✓ <10s]   │
│ Distributed Lock conflicts:         0      [✓]         │
│ Event Sourcing таблица:             2.3M событий       │
└────────────────────────────────────────────────────────┘
```

---

## 5.9 Заключение и чек-лист готовности

### Чек-лист готовности офлайн-режима (перед продом)

**Инфраструктура:**
- [ ] UPS установлены на всех кассовых терминалах (15 мин автономии)
- [ ] Graceful shutdown скрипт настроен (apcupsd)
- [ ] SQLite `synchronous=FULL` включён (защита от power loss)
- [ ] Hybrid Logical Clock реализован и протестирован
- [ ] Circuit Breaker для ОФД работает (тест: 5 ошибок → OPEN)
- [ ] Distributed Lock для синхронизации работает (тест: конкурентные вызовы → 409)

**Мониторинг:**
- [ ] Prometheus exporters работают на всех адаптерах ККТ
- [ ] Grafana dashboard "Офлайн-режим" создан (4 панели)
- [ ] Алерты настроены и протестированы (тестовый алерт отправлен)
- [ ] Jaeger трейсинг работает (проверка: trace_id прослеживается через все сервисы)

**Процедуры:**
- [ ] Decision Tree для L1/L2 распечатан и доступен техподдержке
- [ ] Процедура замены ФН задокументирована (Док.2 §2.10)
- [ ] Процедура переполнения буфера задокументирована (A.1)
- [ ] Процедура Circuit Breaker OPEN задокументирована (A.5)
- [ ] Runbook содержит все сценарии (20+)

**Тестирование:**
- [ ] POC-4 (8ч офлайн) пройден (100%)
- [ ] POC-5 (split-brain, flapping) пройден (100%)
- [ ] UAT-10b/10c (edge-cases) пройдены (100%)
- [ ] Stress-test (2 кассы × 8ч × 50 чеков) пройден
- [ ] Нагрузочный тест (5 касс, 1000 чеков/день) пройден

**Обучение:**
- [ ] Кассиры обучены работе в офлайн-режиме (≥90%)
- [ ] Администраторы знают процедуру принудительной синхронизации
- [ ] L1 техподдержка знает Decision Tree
- [ ] L2 техподдержка знает все процедуры (A.1-A.5)

### Контрольные вопросы (для sign-off)

1. ✅ Что произойдёт, если касса потеряет связь с ОФД на 8 часов?
   - **Ответ:** Касса продолжит работу, чеки накопятся в буфере (до 200), синхронизируются автоматически при восстановлении связи

2. ✅ Что произойдёт, если буфер заполнится до 200 чеков?
   - **Ответ:** Касса заблокирует продажи, алерт P1 администратору, требуется принудительная синхронизация или hot-patch

3. ✅ Что произойдёт при внезапном отключении питания кассы?
   - **Ответ:** UPS даст 15 мин на graceful shutdown, SQLite `synchronous=FULL` гарантирует сохранность последнего чека

4. ✅ Как система защищается от каскадных отказов при проблемах ОФД?
   - **Ответ:** Circuit Breaker размыкается после 5 ошибок подряд, прекращает бесполезные попытки, восстанавливается через 60с

5. ✅ Как предотвращаются дубликаты чеков при конкурентной синхронизации?
   - **Ответ:** Distributed Lock (Redis) гарантирует, что только один процесс синхронизирует буфер, второй получает HTTP 409

6. ✅ Как система разрешает конфликты времени между кассами?
   - **Ответ:** Hybrid Logical Clock (local_time + logical_counter + server_time) гарантирует порядок событий независимо от NTP

**Sign-off:**
Дата: __________
Технический лидер: __________ (подпись)
DevOps: __________ (подпись)
Владелец бизнеса: __________ (подпись)
